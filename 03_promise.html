<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>3. Promise</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: auto; padding: 20px; border: 1px solid lightgray; border-radius: 8px; }
        button { padding: 10px 15px; font-size: 16px; cursor: pointer; margin: 5px; }
        #log { margin-top: 20px; padding: 10px; border: 1px solid black; background-color: ghostwhite; min-height: 150px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>3. Promise로 콜백 지옥 탈출하기</h1>
        <p>Promise의 .then() 체이닝을 통해 코드가 어떻게 개선되는지 확인하세요.</p>
        <button id="success-btn">성공 시나리오</button>
        <button id="fail-btn">실패 시나리오</button>
        <div id="log"></div>
    </div>

    <script>
        const successBtn = document.getElementById('success-btn');
        const failBtn = document.getElementById('fail-btn');
        const logDiv = document.getElementById('log');

        const log = (message, isError = false) => {
            logDiv.innerHTML += `<div style="color: ${isError ? 'red' : 'black'};">${message}</div>`;
        };

        /*
        ==================================================================================
        🎯 Promise란?
        ==================================================================================
        - 비동기 작업의 최종 성공 또는 실패를 나타내는 객체입니다.
        - 성공은 resolve, 실패는 reject 함수를 호출하여 결과를 전달합니다.
        - .then(onFulfilled, onRejected): 작업 성공/실패 시 실행될 함수를 등록합니다.
        - .catch(onRejected): 작업 실패 시 실행될 함수를 등록합니다. .then(null, onRejected)과 같습니다.
        - .finally(onFinally): 성공/실패 여부와 상관없이 마지막에 항상 실행됩니다.
        */

        // Promise를 반환하는 비동기 작업 함수
        function asyncTask(taskName, duration, shouldSucceed) {
            log(`⏳ '${taskName}' 작업 시작...`);
            // Promise 객체를 생성하여 즉시 반환합니다.
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldSucceed) {
                        log(`✅ '${taskName}' 작업 성공!`);
                        resolve(`${taskName}의 결과물`); // 성공 시 resolve 호출
                    } else {
                        log(`❌ '${taskName}' 작업 실패!`);
                        reject(new Error(`'${taskName}'에서 에러 발생`)); // 실패 시 reject 호출
                    }
                }, duration);
            });
        }

        // 성공 시나리오 버튼 클릭 이벤트
        successBtn.addEventListener('click', () => {
            logDiv.innerHTML = '';
            
            asyncTask('사용자 정보 가져오기', 1000, true)
                .then(result1 => {
                    // 첫 번째 작업이 성공하면 그 결과(result1)를 받고, 다음 Promise를 반환합니다.
                    console.log('1차 결과:', result1);
                    return asyncTask('게시물 목록 가져오기', 1000, true);
                })
                .then(result2 => {
                    // 두 번째 작업이 성공하면 그 결과(result2)를 받습니다.
                    console.log('2차 결과:', result2);
                    return asyncTask('댓글 정보 가져오기', 1000, true);
                })
                .then(result3 => {
                    console.log('3차 결과:', result3);
                    log('🎉 모든 작업이 성공적으로 완료되었습니다.');
                })
                .catch(error => {
                    // 이 체인에서 에러는 발생하지 않지만, 만약을 위한 에러 핸들러입니다.
                    log(`에러 발생: ${error.message}`, true);
                });
        });

        // 실패 시나리오 버튼 클릭 이벤트
        failBtn.addEventListener('click', () => {
            logDiv.innerHTML = '';

            asyncTask('사용자 정보 가져오기', 1000, true)
                .then(() => asyncTask('게시물 목록 가져오기 (실패 예정)', 1000, false)) // 여기서 실패 발생
                .then(() => asyncTask('댓글 정보 가져오기', 1000, true)) // 이 코드는 실행되지 않음
                .catch(error => {
                    // 체인 중간에 실패(reject)가 발생하면, 이후의 .then은 건너뛰고
                    // 가장 가까운 .catch 블록이 실행됩니다.
                    log(`❗️ 최종 에러 처리: ${error.message}`, true);
                });
        });
    </script>
</body>
</html>